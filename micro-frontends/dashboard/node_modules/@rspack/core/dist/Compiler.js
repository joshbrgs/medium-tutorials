"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _Compiler_instances, _Compiler_instance, _Compiler_disabledHooks, _Compiler_moduleExecutionResultsMap, _Compiler_getInstance, _Compiler_updateDisabledHooks, _Compiler_beforeCompile, _Compiler_afterCompile, _Compiler_finishMake, _Compiler_buildModule, _Compiler_processAssets, _Compiler_afterProcessAssets, _Compiler_beforeResolve, _Compiler_afterResolve, _Compiler_contextModuleFactoryBeforeResolve, _Compiler_normalModuleFactoryCreateModule, _Compiler_normalModuleFactoryResolveForScheme, _Compiler_optimizeChunkModules, _Compiler_optimizeTree, _Compiler_optimizeModules, _Compiler_afterOptimizeModules, _Compiler_chunkAsset, _Compiler_finishModules, _Compiler_make, _Compiler_shouldEmit, _Compiler_emit, _Compiler_assetEmitted, _Compiler_afterEmit, _Compiler_succeedModule, _Compiler_stillValidModule, _Compiler_runtimeModule, _Compiler_executeModule, _Compiler_collectCompilerHooks, _Compiler_createCompilerCompilationHooks, _Compiler_newCompilation;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Compiler = void 0;
/**
 * The following code is modified based on
 * https://github.com/webpack/webpack/blob/4b4ca3bb53f36a5b8fc6bc1bd976ed7af161bd80/lib/Compiler.js
 *
 * MIT Licensed
 * Author Tobias Koppers @sokra
 * Copyright (c) JS Foundation and other contributors
 * https://github.com/webpack/webpack/blob/main/LICENSE
 */
const binding = __importStar(require("@rspack/binding"));
const index_1 = require("./index");
const fs_1 = __importDefault(require("fs"));
const tapable = __importStar(require("tapable"));
const tapable_1 = require("tapable");
const RuleSetCompiler_1 = require("./RuleSetCompiler");
const Stats_1 = require("./Stats");
const Compilation_1 = require("./Compilation");
const ContextModuleFactory_1 = require("./ContextModuleFactory");
const ResolverFactory_1 = __importDefault(require("./ResolverFactory"));
const config_1 = require("./config");
const ConcurrentCompilationError_1 = __importDefault(require("./error/ConcurrentCompilationError"));
const fileSystem_1 = require("./fileSystem");
const Cache_1 = __importDefault(require("./lib/Cache"));
const CacheFacade_1 = __importDefault(require("./lib/CacheFacade"));
const loader_runner_1 = require("./loader-runner");
const Logger_1 = require("./logging/Logger");
const NormalModuleFactory_1 = require("./NormalModuleFactory");
const bindingVersionCheck_1 = require("./util/bindingVersionCheck");
const Watching_1 = require("./Watching");
const NormalModule_1 = require("./NormalModule");
const normalization_1 = require("./util/normalization");
const builtin_plugin_1 = require("./builtin-plugin");
const rspackOptionsApply_1 = require("./rspackOptionsApply");
const defaults_1 = require("./config/defaults");
const assertNotNil_1 = require("./util/assertNotNil");
const RuntimeGlobals_1 = require("./RuntimeGlobals");
const HookWebpackError_1 = require("./lib/HookWebpackError");
const Module_1 = require("./Module");
const base_1 = require("./builtin-plugin/base");
const ExecuteModulePlugin_1 = __importDefault(require("./ExecuteModulePlugin"));
class Compiler {
    constructor(context, options) {
        _Compiler_instances.add(this);
        _Compiler_instance.set(this, void 0);
        this.webpack = index_1.rspack;
        // TODO: remove this after remove rebuild on the rust side.
        this.first = true;
        _Compiler_disabledHooks.set(this, void 0);
        _Compiler_moduleExecutionResultsMap.set(this, void 0);
        this.outputFileSystem = fs_1.default;
        this.options = options;
        this.cache = new Cache_1.default();
        this.compilerPath = "";
        this.builtinPlugins = [];
        this.root = this;
        this.ruleSet = new RuleSetCompiler_1.RuleSetCompiler();
        this.running = false;
        this.idle = false;
        this.context = context;
        this.resolverFactory = new ResolverFactory_1.default();
        this.modifiedFiles = undefined;
        this.removedFiles = undefined;
        this.hooks = {
            initialize: new tapable_1.SyncHook([]),
            shouldEmit: new tapable.SyncBailHook(["compilation"]),
            done: new tapable.AsyncSeriesHook(["stats"]),
            afterDone: new tapable.SyncHook(["stats"]),
            beforeRun: new tapable.AsyncSeriesHook(["compiler"]),
            run: new tapable.AsyncSeriesHook(["compiler"]),
            emit: new tapable.AsyncSeriesHook(["compilation"]),
            assetEmitted: new tapable.AsyncSeriesHook(["file", "info"]),
            afterEmit: new tapable.AsyncSeriesHook(["compilation"]),
            thisCompilation: new tapable.SyncHook([
                "compilation",
                "params"
            ]),
            compilation: new tapable.SyncHook([
                "compilation",
                "params"
            ]),
            invalid: new tapable_1.SyncHook(["filename", "changeTime"]),
            compile: new tapable_1.SyncHook(["params"]),
            infrastructureLog: new tapable_1.SyncBailHook(["origin", "type", "args"]),
            failed: new tapable_1.SyncHook(["error"]),
            shutdown: new tapable.AsyncSeriesHook([]),
            normalModuleFactory: new tapable.SyncHook([
                "normalModuleFactory"
            ]),
            contextModuleFactory: new tapable.SyncHook([
                "contextModuleFactory"
            ]),
            watchRun: new tapable.AsyncSeriesHook(["compiler"]),
            watchClose: new tapable.SyncHook([]),
            environment: new tapable.SyncHook([]),
            afterEnvironment: new tapable.SyncHook([]),
            afterPlugins: new tapable.SyncHook(["compiler"]),
            afterResolvers: new tapable.SyncHook(["compiler"]),
            make: new tapable.AsyncParallelHook(["compilation"]),
            beforeCompile: new tapable.AsyncSeriesHook(["params"]),
            afterCompile: new tapable.AsyncSeriesHook(["compilation"]),
            finishMake: new tapable.AsyncSeriesHook(["compilation"]),
            finishModules: new tapable.AsyncSeriesHook(["modules"]),
            entryOption: new tapable.SyncBailHook(["context", "entry"])
        };
        this.modifiedFiles = undefined;
        this.removedFiles = undefined;
        __classPrivateFieldSet(this, _Compiler_disabledHooks, [], "f");
        __classPrivateFieldSet(this, _Compiler_moduleExecutionResultsMap, new Map(), "f");
        new ExecuteModulePlugin_1.default().apply(this);
    }
    /**
     * @param {string} name cache name
     * @returns {CacheFacade} the cache facade instance
     */
    getCache(name) {
        return new CacheFacade_1.default(this.cache, `${this.compilerPath}${name}`, this.options.output.hashFunction);
    }
    createChildCompiler(compilation, compilerName, compilerIndex, outputOptions, plugins) {
        const options = {
            ...this.options,
            output: {
                ...this.options.output,
                ...outputOptions
            },
            // TODO: check why we need to have builtins otherwise this.#instance will fail to initialize Rspack
            builtins: this.options.builtins
        };
        (0, defaults_1.applyRspackOptionsDefaults)(options);
        const childCompiler = new Compiler(this.context, options);
        childCompiler.name = compilerName;
        childCompiler.outputPath = this.outputPath;
        childCompiler.inputFileSystem = this.inputFileSystem;
        // childCompiler.outputFileSystem = null;
        childCompiler.resolverFactory = this.resolverFactory;
        childCompiler.modifiedFiles = this.modifiedFiles;
        childCompiler.removedFiles = this.removedFiles;
        // childCompiler.fileTimestamps = this.fileTimestamps;
        // childCompiler.contextTimestamps = this.contextTimestamps;
        // childCompiler.fsStartTime = this.fsStartTime;
        childCompiler.cache = this.cache;
        childCompiler.compilerPath = `${this.compilerPath}${compilerName}|${compilerIndex}|`;
        // childCompiler._backCompat = this._backCompat;
        // const relativeCompilerName = makePathsRelative(
        // 	this.context,
        // 	compilerName,
        // 	this.root
        // );
        // if (!this.records[relativeCompilerName]) {
        // 	this.records[relativeCompilerName] = [];
        // }
        // if (this.records[relativeCompilerName][compilerIndex]) {
        // 	childCompiler.records = this.records[relativeCompilerName][compilerIndex];
        // } else {
        // 	this.records[relativeCompilerName].push((childCompiler.records = {}));
        // }
        childCompiler.parentCompilation = compilation;
        childCompiler.root = this.root;
        if (Array.isArray(plugins)) {
            for (const plugin of plugins) {
                if (plugin) {
                    plugin.apply(childCompiler);
                }
            }
        }
        childCompiler.builtinPlugins = [
            ...childCompiler.builtinPlugins,
            ...this.builtinPlugins.filter(plugin => plugin.canInherentFromParent === true)
        ];
        for (const name in this.hooks) {
            if ((0, base_1.canInherentFromParent)(name)) {
                //@ts-ignore
                if (childCompiler.hooks[name]) {
                    //@ts-ignore
                    childCompiler.hooks[name].taps = this.hooks[name].taps.slice();
                }
            }
        }
        compilation.hooks.childCompiler.call(childCompiler, compilerName, compilerIndex);
        return childCompiler;
    }
    runAsChild(callback) {
        const finalCallback = (err, entries, compilation) => {
            try {
                callback(err, entries, compilation);
            }
            catch (e) {
                const err = new Error(`compiler.runAsChild callback error: ${e}`);
                // err.details = e.stack;
                this.parentCompilation.errors.push(err);
                // TODO: remove once this works
                console.log(e);
            }
        };
        this.compile((err, compilation) => {
            if (err) {
                return finalCallback(err);
            }
            (0, assertNotNil_1.assertNotNill)(compilation);
            this.parentCompilation.children.push(compilation);
            for (const { name, source, info } of compilation.getAssets()) {
                // Do not emit asset if source is not available.
                // Webpack will emit it anyway.
                if (source) {
                    this.parentCompilation.emitAsset(name, source, info);
                }
            }
            const entries = [];
            for (const ep of compilation.entrypoints.values()) {
                entries.push(...ep.getFiles());
            }
            return finalCallback(null, entries, compilation);
        });
    }
    isChild() {
        const isRoot = this.root === this;
        return !isRoot;
    }
    getInfrastructureLogger(name) {
        if (!name) {
            throw new TypeError("Compiler.getInfrastructureLogger(name) called without a name");
        }
        return new Logger_1.Logger((type, args) => {
            if (typeof name === "function") {
                name = name();
                if (!name) {
                    throw new TypeError("Compiler.getInfrastructureLogger(name) called with a function not returning a name");
                }
            }
            else {
                if (
                // @ts-expect-error
                this.hooks.infrastructureLog.call(name, type, args) === undefined) {
                    if (this.infrastructureLogger !== undefined) {
                        this.infrastructureLogger(name, type, args);
                    }
                }
            }
        }, (childName) => {
            if (typeof name === "function") {
                if (typeof childName === "function") {
                    // @ts-expect-error
                    return this.getInfrastructureLogger(_ => {
                        if (typeof name === "function") {
                            name = name();
                            if (!name) {
                                throw new TypeError("Compiler.getInfrastructureLogger(name) called with a function not returning a name");
                            }
                        }
                        if (typeof childName === "function") {
                            childName = childName();
                            if (!childName) {
                                throw new TypeError("Logger.getChildLogger(name) called with a function not returning a name");
                            }
                        }
                        return `${name}/${childName}`;
                    });
                }
                else {
                    return this.getInfrastructureLogger(() => {
                        if (typeof name === "function") {
                            name = name();
                            if (!name) {
                                throw new TypeError("Compiler.getInfrastructureLogger(name) called with a function not returning a name");
                            }
                        }
                        return `${name}/${childName}`;
                    });
                }
            }
            else {
                if (typeof childName === "function") {
                    return this.getInfrastructureLogger(() => {
                        if (typeof childName === "function") {
                            childName = childName();
                            if (!childName) {
                                throw new TypeError("Logger.getChildLogger(name) called with a function not returning a name");
                            }
                        }
                        return `${name}/${childName}`;
                    });
                }
                else {
                    return this.getInfrastructureLogger(`${name}/${childName}`);
                }
            }
        });
    }
    run(callback) {
        if (this.running) {
            return callback(new ConcurrentCompilationError_1.default());
        }
        const startTime = Date.now();
        this.running = true;
        const doRun = () => {
            // @ts-expect-error
            const finalCallback = (err, stats) => {
                this.idle = true;
                this.cache.beginIdle();
                this.idle = true;
                this.running = false;
                if (err) {
                    this.hooks.failed.call(err);
                }
                if (callback) {
                    callback(err, stats);
                }
                this.hooks.afterDone.call(stats);
            };
            this.hooks.beforeRun.callAsync(this, err => {
                if (err) {
                    return finalCallback(err);
                }
                this.hooks.run.callAsync(this, err => {
                    if (err) {
                        return finalCallback(err);
                    }
                    this.build(err => {
                        if (err) {
                            return finalCallback(err);
                        }
                        this.compilation.startTime = startTime;
                        this.compilation.endTime = Date.now();
                        const stats = new Stats_1.Stats(this.compilation);
                        this.hooks.done.callAsync(stats, err => {
                            if (err) {
                                return finalCallback(err);
                            }
                            else {
                                return finalCallback(null, stats);
                            }
                        });
                    });
                });
            });
        };
        if (this.idle) {
            this.cache.endIdle(err => {
                if (err)
                    return callback(err);
                this.idle = false;
                doRun();
            });
        }
        else {
            doRun();
        }
    }
    /**
     * Safety: This method is only valid to call if the previous rebuild task is finished, or there will be data races.
     */
    build(callback) {
        __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_getInstance).call(this, (error, instance) => {
            if (error) {
                return callback === null || callback === void 0 ? void 0 : callback(error);
            }
            if (!this.first) {
                const rebuild = instance.unsafe_rebuild.bind(instance);
                rebuild(Array.from(this.modifiedFiles || []), Array.from(this.removedFiles || []), error => {
                    if (error) {
                        return callback === null || callback === void 0 ? void 0 : callback(error);
                    }
                    callback === null || callback === void 0 ? void 0 : callback(null);
                });
                return;
            }
            this.first = false;
            const build = instance.unsafe_build.bind(instance);
            build(error => {
                if (error) {
                    return callback === null || callback === void 0 ? void 0 : callback(error);
                }
                callback === null || callback === void 0 ? void 0 : callback(null);
            });
        });
    }
    /**
     * Safety: This method is only valid to call if the previous rebuild task is finished, or there will be data races.
     * @deprecated This is a low-level incremental rebuild API, which shouldn't be used intentionally. Use `compiler.build` instead.
     */
    rebuild(modifiedFiles, removedFiles, callback) {
        __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_getInstance).call(this, (error, instance) => {
            if (error) {
                return callback === null || callback === void 0 ? void 0 : callback(error);
            }
            const rebuild = instance.unsafe_rebuild.bind(instance);
            rebuild(Array.from(modifiedFiles || []), Array.from(removedFiles || []), error => {
                if (error) {
                    return callback === null || callback === void 0 ? void 0 : callback(error);
                }
                callback === null || callback === void 0 ? void 0 : callback(null);
            });
        });
    }
    compile(callback) {
        const startTime = Date.now();
        this.hooks.beforeCompile.callAsync(void 0, (err) => {
            if (err) {
                return callback(err);
            }
            this.hooks.compile.call([]);
            this.build(err => {
                if (err) {
                    return callback(err);
                }
                this.compilation.startTime = startTime;
                this.compilation.endTime = Date.now();
                this.hooks.afterCompile.callAsync(this.compilation, err => {
                    if (err) {
                        return callback(err);
                    }
                    return callback(null, this.compilation);
                });
            });
        });
    }
    watch(watchOptions, handler) {
        if (this.running) {
            // @ts-expect-error
            return handler(new ConcurrentCompilationError_1.default());
        }
        this.running = true;
        this.watchMode = true;
        // @ts-expect-error
        this.watching = new Watching_1.Watching(this, watchOptions, handler);
        return this.watching;
    }
    purgeInputFileSystem() {
        if (this.inputFileSystem && this.inputFileSystem.purge) {
            this.inputFileSystem.purge();
        }
    }
    close(callback) {
        // WARNING: Arbitrarily dropping the instance is not safe, as it may still be in use by the background thread.
        // A hint is necessary for the compiler to know when it is safe to drop the instance.
        // For example: register a callback to the background thread, and drop the instance when the callback is called (calling the `close` method queues the signal)
        // See: https://github.com/webpack/webpack/blob/4ba225225b1348c8776ca5b5fe53468519413bc0/lib/Compiler.js#L1218
        if (!this.running) {
            // Manually drop the instance.
            // this.#instance = undefined;
        }
        if (this.watching) {
            // When there is still an active watching, close this first
            this.watching.close(() => {
                this.close(callback);
            });
            return;
        }
        this.hooks.shutdown.callAsync(err => {
            if (err)
                return callback(err);
            this.cache.shutdown(callback);
        });
    }
    getAsset(name) {
        let source = this.compilation.__internal__getAssetSource(name);
        if (!source) {
            return null;
        }
        return source.buffer();
    }
    __internal__registerBuiltinPlugin(plugin) {
        this.builtinPlugins.push(plugin);
    }
    __internal__getModuleExecutionResult(id) {
        return __classPrivateFieldGet(this, _Compiler_moduleExecutionResultsMap, "f").get(id);
    }
}
exports.Compiler = Compiler;
_Compiler_instance = new WeakMap(), _Compiler_disabledHooks = new WeakMap(), _Compiler_moduleExecutionResultsMap = new WeakMap(), _Compiler_instances = new WeakSet(), _Compiler_getInstance = function _Compiler_getInstance(callback) {
    const error = (0, bindingVersionCheck_1.checkVersion)();
    if (error) {
        return callback(error);
    }
    if (__classPrivateFieldGet(this, _Compiler_instance, "f")) {
        return callback(null, __classPrivateFieldGet(this, _Compiler_instance, "f"));
    }
    const options = this.options;
    // TODO: remove this in v0.6
    if (!options.experiments.rspackFuture.disableApplyEntryLazily) {
        (0, rspackOptionsApply_1.applyEntryOptions)(this, options);
    }
    // TODO: remove this when drop support for builtins options
    options.builtins = (0, builtin_plugin_1.deprecated_resolveBuiltins)(options.builtins, options, this);
    const rawOptions = (0, config_1.getRawOptions)(options, this);
    const instanceBinding = require("@rspack/binding");
    __classPrivateFieldSet(this, _Compiler_instance, new instanceBinding.Rspack(rawOptions, this.builtinPlugins, {
        beforeCompile: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_beforeCompile).bind(this),
        afterCompile: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_afterCompile).bind(this),
        finishMake: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_finishMake).bind(this),
        make: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_make).bind(this),
        shouldEmit: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_shouldEmit).bind(this),
        emit: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_emit).bind(this),
        assetEmitted: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_assetEmitted).bind(this),
        afterEmit: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_afterEmit).bind(this),
        processAssetsStageAdditional: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_processAssets).bind(this, Compilation_1.Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL),
        processAssetsStagePreProcess: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_processAssets).bind(this, Compilation_1.Compilation.PROCESS_ASSETS_STAGE_PRE_PROCESS),
        processAssetsStageDerived: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_processAssets).bind(this, Compilation_1.Compilation.PROCESS_ASSETS_STAGE_DERIVED),
        processAssetsStageAdditions: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_processAssets).bind(this, Compilation_1.Compilation.PROCESS_ASSETS_STAGE_ADDITIONS),
        processAssetsStageNone: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_processAssets).bind(this, Compilation_1.Compilation.PROCESS_ASSETS_STAGE_NONE),
        processAssetsStageOptimize: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_processAssets).bind(this, Compilation_1.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE),
        processAssetsStageOptimizeCount: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_processAssets).bind(this, Compilation_1.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_COUNT),
        processAssetsStageOptimizeCompatibility: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_processAssets).bind(this, Compilation_1.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_COMPATIBILITY),
        processAssetsStageOptimizeSize: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_processAssets).bind(this, Compilation_1.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_SIZE),
        processAssetsStageDevTooling: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_processAssets).bind(this, Compilation_1.Compilation.PROCESS_ASSETS_STAGE_DEV_TOOLING),
        processAssetsStageOptimizeInline: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_processAssets).bind(this, Compilation_1.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_INLINE),
        processAssetsStageSummarize: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_processAssets).bind(this, Compilation_1.Compilation.PROCESS_ASSETS_STAGE_SUMMARIZE),
        processAssetsStageOptimizeHash: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_processAssets).bind(this, Compilation_1.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_HASH),
        processAssetsStageOptimizeTransfer: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_processAssets).bind(this, Compilation_1.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_TRANSFER),
        processAssetsStageAnalyse: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_processAssets).bind(this, Compilation_1.Compilation.PROCESS_ASSETS_STAGE_ANALYSE),
        processAssetsStageReport: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_processAssets).bind(this, Compilation_1.Compilation.PROCESS_ASSETS_STAGE_REPORT),
        afterProcessAssets: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_afterProcessAssets).bind(this),
        // `Compilation` should be created with hook `thisCompilation`, and here is the reason:
        // We know that the hook `thisCompilation` will not be called from a child compiler(it doesn't matter whether the child compiler is created on the Rust or the Node side).
        // See webpack's API: https://webpack.js.org/api/compiler-hooks/#thiscompilation
        // So it is safe to create a new compilation here.
        thisCompilation: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_newCompilation).bind(this),
        optimizeModules: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_optimizeModules).bind(this),
        afterOptimizeModules: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_afterOptimizeModules).bind(this),
        optimizeTree: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_optimizeTree).bind(this),
        optimizeChunkModules: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_optimizeChunkModules).bind(this),
        finishModules: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_finishModules).bind(this),
        normalModuleFactoryCreateModule: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_normalModuleFactoryCreateModule).bind(this),
        normalModuleFactoryResolveForScheme: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_normalModuleFactoryResolveForScheme).bind(this),
        chunkAsset: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_chunkAsset).bind(this),
        beforeResolve: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_beforeResolve).bind(this),
        afterResolve: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_afterResolve).bind(this),
        contextModuleFactoryBeforeResolve: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_contextModuleFactoryBeforeResolve).bind(this),
        succeedModule: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_succeedModule).bind(this),
        stillValidModule: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_stillValidModule).bind(this),
        buildModule: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_buildModule).bind(this),
        executeModule: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_executeModule).bind(this),
        runtimeModule: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_runtimeModule).bind(this)
    }, __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_collectCompilerHooks).call(this), (0, fileSystem_1.createThreadsafeNodeFSFromRaw)(this.outputFileSystem), loader_runner_1.runLoaders.bind(undefined, this)), "f");
    callback(null, __classPrivateFieldGet(this, _Compiler_instance, "f"));
}, _Compiler_updateDisabledHooks = function _Compiler_updateDisabledHooks(callback) {
    var _a, _b, _c, _d, _e;
    const disabledHooks = [];
    const hookMap = {
        make: this.hooks.make,
        beforeCompile: this.hooks.beforeCompile,
        afterCompile: this.hooks.afterCompile,
        finishMake: this.hooks.finishMake,
        shouldEmit: this.hooks.shouldEmit,
        emit: this.hooks.emit,
        assetEmitted: this.hooks.assetEmitted,
        afterEmit: this.hooks.afterEmit,
        processAssetsStageAdditional: this.compilation.__internal_getProcessAssetsHookByStage(Compilation_1.Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL),
        processAssetsStagePreProcess: this.compilation.__internal_getProcessAssetsHookByStage(Compilation_1.Compilation.PROCESS_ASSETS_STAGE_PRE_PROCESS),
        processAssetsStageDerived: this.compilation.__internal_getProcessAssetsHookByStage(Compilation_1.Compilation.PROCESS_ASSETS_STAGE_DERIVED),
        processAssetsStageAdditions: this.compilation.__internal_getProcessAssetsHookByStage(Compilation_1.Compilation.PROCESS_ASSETS_STAGE_ADDITIONS),
        processAssetsStageNone: this.compilation.__internal_getProcessAssetsHookByStage(Compilation_1.Compilation.PROCESS_ASSETS_STAGE_NONE),
        processAssetsStageOptimize: this.compilation.__internal_getProcessAssetsHookByStage(Compilation_1.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE),
        processAssetsStageOptimizeCount: this.compilation.__internal_getProcessAssetsHookByStage(Compilation_1.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_COUNT),
        processAssetsStageOptimizeCompatibility: this.compilation.__internal_getProcessAssetsHookByStage(Compilation_1.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_COMPATIBILITY),
        processAssetsStageOptimizeSize: this.compilation.__internal_getProcessAssetsHookByStage(Compilation_1.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_SIZE),
        processAssetsStageDevTooling: this.compilation.__internal_getProcessAssetsHookByStage(Compilation_1.Compilation.PROCESS_ASSETS_STAGE_DEV_TOOLING),
        processAssetsStageOptimizeInline: this.compilation.__internal_getProcessAssetsHookByStage(Compilation_1.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_INLINE),
        processAssetsStageSummarize: this.compilation.__internal_getProcessAssetsHookByStage(Compilation_1.Compilation.PROCESS_ASSETS_STAGE_SUMMARIZE),
        processAssetsStageOptimizeHash: this.compilation.__internal_getProcessAssetsHookByStage(Compilation_1.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_HASH),
        processAssetsStageOptimizeTransfer: this.compilation.__internal_getProcessAssetsHookByStage(Compilation_1.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_TRANSFER),
        processAssetsStageAnalyse: this.compilation.__internal_getProcessAssetsHookByStage(Compilation_1.Compilation.PROCESS_ASSETS_STAGE_ANALYSE),
        processAssetsStageReport: this.compilation.__internal_getProcessAssetsHookByStage(Compilation_1.Compilation.PROCESS_ASSETS_STAGE_REPORT),
        afterProcessAssets: this.compilation.hooks.afterProcessAssets,
        optimizeTree: this.compilation.hooks.optimizeTree,
        finishModules: this.compilation.hooks.finishModules,
        optimizeModules: this.compilation.hooks.optimizeModules,
        afterOptimizeModules: this.compilation.hooks.afterOptimizeModules,
        chunkAsset: this.compilation.hooks.chunkAsset,
        beforeResolve: (_a = this.compilation.normalModuleFactory) === null || _a === void 0 ? void 0 : _a.hooks.beforeResolve,
        afterResolve: (_b = this.compilation.normalModuleFactory) === null || _b === void 0 ? void 0 : _b.hooks.afterResolve,
        succeedModule: this.compilation.hooks.succeedModule,
        stillValidModule: this.compilation.hooks.stillValidModule,
        buildModule: this.compilation.hooks.buildModule,
        // various of hooks are called inside `#newCompilation`, we shouldn't prevent `#newCompilation` from calling even when `thisCompilation` is not tapped.
        // issue: https://github.com/web-infra-dev/rspack/issues/5398
        thisCompilation: undefined,
        optimizeChunkModules: this.compilation.hooks.optimizeChunkModules,
        contextModuleFactoryBeforeResolve: (_c = this.compilation.contextModuleFactory) === null || _c === void 0 ? void 0 : _c.hooks.beforeResolve,
        normalModuleFactoryCreateModule: (_d = this.compilation.normalModuleFactory) === null || _d === void 0 ? void 0 : _d.hooks.createModule,
        normalModuleFactoryResolveForScheme: (_e = this.compilation.normalModuleFactory) === null || _e === void 0 ? void 0 : _e.hooks.resolveForScheme,
        executeModule: undefined,
        runtimeModule: this.compilation.hooks.runtimeModule
    };
    for (const [name, hook] of Object.entries(hookMap)) {
        if (typeof hook !== "undefined" &&
            (hook.taps
                ? hook.taps.length === 0
                : hook._map
                    ? /* hook map */ hook._map.size === 0
                    : false)) {
            disabledHooks.push(name);
        }
    }
    // disabledHooks is in order
    if (__classPrivateFieldGet(this, _Compiler_disabledHooks, "f").join() !== disabledHooks.join()) {
        __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_getInstance).call(this, (error, instance) => {
            if (error) {
                return callback === null || callback === void 0 ? void 0 : callback(error);
            }
            instance.unsafe_set_disabled_hooks(disabledHooks);
            __classPrivateFieldSet(this, _Compiler_disabledHooks, disabledHooks, "f");
        });
    }
}, _Compiler_beforeCompile = async function _Compiler_beforeCompile() {
    await this.hooks.beforeCompile.promise();
    // compilation is not created yet, so this will fail
    // this.#updateDisabledHooks();
}, _Compiler_afterCompile = async function _Compiler_afterCompile() {
    await this.hooks.afterCompile.promise(this.compilation);
    __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_updateDisabledHooks).call(this);
}, _Compiler_finishMake = async function _Compiler_finishMake() {
    await this.hooks.finishMake.promise(this.compilation);
    __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_updateDisabledHooks).call(this);
}, _Compiler_buildModule = async function _Compiler_buildModule(module) {
    const normalized = (0, normalization_1.normalizeJsModule)(module);
    this.compilation.hooks.buildModule.call(normalized);
    __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_updateDisabledHooks).call(this);
}, _Compiler_processAssets = async function _Compiler_processAssets(stage) {
    await this.compilation
        .__internal_getProcessAssetsHookByStage(stage)
        .promise(this.compilation.assets);
    __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_updateDisabledHooks).call(this);
}, _Compiler_afterProcessAssets = async function _Compiler_afterProcessAssets() {
    await this.compilation.hooks.afterProcessAssets.promise(this.compilation.assets);
    __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_updateDisabledHooks).call(this);
}, _Compiler_beforeResolve = async function _Compiler_beforeResolve(resolveData) {
    var _a;
    const normalizedResolveData = {
        request: resolveData.request,
        context: resolveData.context,
        fileDependencies: [],
        missingDependencies: [],
        contextDependencies: []
    };
    let ret = await ((_a = this.compilation.normalModuleFactory) === null || _a === void 0 ? void 0 : _a.hooks.beforeResolve.promise(normalizedResolveData));
    __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_updateDisabledHooks).call(this);
    resolveData.request = normalizedResolveData.request;
    resolveData.context = normalizedResolveData.context;
    return [ret, resolveData];
}, _Compiler_afterResolve = async function _Compiler_afterResolve(resolveData) {
    var _a;
    let res = await ((_a = this.compilation.normalModuleFactory) === null || _a === void 0 ? void 0 : _a.hooks.afterResolve.promise(resolveData));
    NormalModule_1.NormalModule.getCompilationHooks(this.compilation).loader.tap("sideEffectFreePropPlugin", (loaderContext) => {
        loaderContext._module = {
            factoryMeta: {
                sideEffectFree: !!resolveData.factoryMeta.sideEffectFree
            }
        };
    });
    __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_updateDisabledHooks).call(this);
    return res;
}, _Compiler_contextModuleFactoryBeforeResolve = async function _Compiler_contextModuleFactoryBeforeResolve(resourceData) {
    var _a;
    let res = await ((_a = this.compilation.contextModuleFactory) === null || _a === void 0 ? void 0 : _a.hooks.beforeResolve.promise(resourceData));
    __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_updateDisabledHooks).call(this);
    return res;
}, _Compiler_normalModuleFactoryCreateModule = async function _Compiler_normalModuleFactoryCreateModule(createData) {
    var _a;
    const data = Object.assign({}, createData, {
        settings: {},
        matchResource: createData.resourceResolveData.resource
    });
    const nmfHooks = (_a = this.compilation.normalModuleFactory) === null || _a === void 0 ? void 0 : _a.hooks;
    await (nmfHooks === null || nmfHooks === void 0 ? void 0 : nmfHooks.createModule.promise(data, {}));
    __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_updateDisabledHooks).call(this);
}, _Compiler_normalModuleFactoryResolveForScheme = async function _Compiler_normalModuleFactoryResolveForScheme(input) {
    var _a;
    let stop = await ((_a = this.compilation.normalModuleFactory) === null || _a === void 0 ? void 0 : _a.hooks.resolveForScheme.for(input.scheme).promise(input.resourceData));
    __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_updateDisabledHooks).call(this);
    return {
        resourceData: input.resourceData,
        stop: stop === true
    };
}, _Compiler_optimizeChunkModules = async function _Compiler_optimizeChunkModules() {
    await this.compilation.hooks.optimizeChunkModules.promise(this.compilation.chunks, this.compilation.modules);
    __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_updateDisabledHooks).call(this);
}, _Compiler_optimizeTree = async function _Compiler_optimizeTree() {
    await this.compilation.hooks.optimizeTree.promise(this.compilation.chunks, this.compilation.modules);
    __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_updateDisabledHooks).call(this);
}, _Compiler_optimizeModules = async function _Compiler_optimizeModules() {
    await this.compilation.hooks.optimizeModules.promise(this.compilation.modules);
    __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_updateDisabledHooks).call(this);
}, _Compiler_afterOptimizeModules = async function _Compiler_afterOptimizeModules() {
    await this.compilation.hooks.afterOptimizeModules.promise(this.compilation.modules);
    __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_updateDisabledHooks).call(this);
}, _Compiler_chunkAsset = function _Compiler_chunkAsset(assetArg) {
    this.compilation.hooks.chunkAsset.call(assetArg.chunk, assetArg.filename);
    __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_updateDisabledHooks).call(this);
}, _Compiler_finishModules = async function _Compiler_finishModules() {
    await this.compilation.hooks.finishModules.promise(this.compilation.modules);
    __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_updateDisabledHooks).call(this);
}, _Compiler_make = async function _Compiler_make() {
    await this.hooks.make.promise(this.compilation);
    __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_updateDisabledHooks).call(this);
}, _Compiler_shouldEmit = async function _Compiler_shouldEmit() {
    const res = this.hooks.shouldEmit.call(this.compilation);
    __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_updateDisabledHooks).call(this);
    return Promise.resolve(res);
}, _Compiler_emit = async function _Compiler_emit() {
    await this.hooks.emit.promise(this.compilation);
    __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_updateDisabledHooks).call(this);
}, _Compiler_assetEmitted = async function _Compiler_assetEmitted(args) {
    const filename = args.filename;
    const info = {
        compilation: this.compilation,
        outputPath: args.outputPath,
        targetPath: args.targetPath,
        get source() {
            var _a;
            return (_a = this.compilation.getAsset(args.filename)) === null || _a === void 0 ? void 0 : _a.source;
        },
        get content() {
            var _a;
            return (_a = this.source) === null || _a === void 0 ? void 0 : _a.buffer();
        }
    };
    await this.hooks.assetEmitted.promise(filename, info);
    __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_updateDisabledHooks).call(this);
}, _Compiler_afterEmit = async function _Compiler_afterEmit() {
    await this.hooks.afterEmit.promise(this.compilation);
    __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_updateDisabledHooks).call(this);
}, _Compiler_succeedModule = function _Compiler_succeedModule(module) {
    this.compilation.hooks.succeedModule.call(module);
    __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_updateDisabledHooks).call(this);
}, _Compiler_stillValidModule = function _Compiler_stillValidModule(module) {
    this.compilation.hooks.stillValidModule.call(module);
    __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_updateDisabledHooks).call(this);
}, _Compiler_runtimeModule = function _Compiler_runtimeModule(arg) {
    var _a, _b;
    let { module, chunk } = arg;
    const originSource = (_a = module.source) === null || _a === void 0 ? void 0 : _a.source;
    this.compilation.hooks.runtimeModule.call(module, chunk);
    __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_updateDisabledHooks).call(this);
    const newSource = (_b = module.source) === null || _b === void 0 ? void 0 : _b.source;
    if (newSource && newSource !== originSource) {
        return module;
    }
    return;
}, _Compiler_executeModule = async function _Compiler_executeModule({ entry, request, options, runtimeModules, codegenResults, id }) {
    const __webpack_require__ = (id) => {
        const cached = moduleCache[id];
        if (cached !== undefined) {
            if (cached.error)
                throw cached.error;
            return cached.exports;
        }
        var execOptions = {
            id,
            module: {
                id,
                exports: {},
                loaded: false,
                error: undefined
            },
            require: __webpack_require__
        };
        interceptModuleExecution.forEach((handler) => handler(execOptions));
        const result = codegenResults.map[id]["build time"];
        const moduleObject = execOptions.module;
        if (id)
            moduleCache[id] = moduleObject;
        (0, HookWebpackError_1.tryRunOrWebpackError)(() => this.compilation.hooks.executeModule.call({
            codeGenerationResult: new Module_1.CodeGenerationResult(result),
            moduleObject
        }, { __webpack_require__ }), "Compilation.hooks.executeModule");
        moduleObject.loaded = true;
        return moduleObject.exports;
    };
    const moduleCache = (__webpack_require__[RuntimeGlobals_1.RuntimeGlobals.moduleCache.replace(`${RuntimeGlobals_1.RuntimeGlobals.require}.`, "")] = {});
    const interceptModuleExecution = (__webpack_require__[RuntimeGlobals_1.RuntimeGlobals.interceptModuleExecution.replace(`${RuntimeGlobals_1.RuntimeGlobals.require}.`, "")] = []);
    for (const runtimeModule of runtimeModules) {
        __webpack_require__(runtimeModule);
    }
    const executeResult = __webpack_require__(entry);
    __classPrivateFieldGet(this, _Compiler_moduleExecutionResultsMap, "f").set(id, executeResult);
}, _Compiler_collectCompilerHooks = function _Compiler_collectCompilerHooks() {
    return [...__classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createCompilerCompilationHooks).call(this)];
}, _Compiler_createCompilerCompilationHooks = function _Compiler_createCompilerCompilationHooks() {
    if (this.hooks.compilation.taps.length <= 0)
        return [];
    return [
        {
            type: binding.JsHookType.CompilerCompilation,
            function: (native) => {
                this.hooks.compilation.call(this.compilation, {
                    normalModuleFactory: this.compilation.normalModuleFactory
                });
                __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_updateDisabledHooks).call(this);
            }
        }
    ];
}, _Compiler_newCompilation = function _Compiler_newCompilation(native) {
    const compilation = new Compilation_1.Compilation(this, native);
    compilation.name = this.name;
    this.compilation = compilation;
    // reset normalModuleFactory when create new compilation
    let normalModuleFactory = new NormalModuleFactory_1.NormalModuleFactory();
    let contextModuleFactory = new ContextModuleFactory_1.ContextModuleFactory();
    this.compilation.normalModuleFactory = normalModuleFactory;
    this.hooks.normalModuleFactory.call(normalModuleFactory);
    this.compilation.contextModuleFactory = contextModuleFactory;
    this.hooks.contextModuleFactory.call(normalModuleFactory);
    this.hooks.thisCompilation.call(this.compilation, {
        normalModuleFactory: normalModuleFactory
    });
    __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_updateDisabledHooks).call(this);
};
//# sourceMappingURL=Compiler.js.map